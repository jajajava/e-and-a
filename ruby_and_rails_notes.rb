#* Similarly to how React takes JavaScript and changes the way you write with it, Rails replaces the need for raw Ruby code.

#* We are going to use Rails as an API

#* In order to make a minimal API using Rails, you can type the following command:
#// rails new app_name --api --minimal

#! PLURALIZATION IN RAILS:
#* Migrations - plural
#* Tables - plural
#* Model - singular
#* Serializer - singular
#* PRETTY MUCH EVERYTHING BUT MODEL/SERIALIZER IS PLURALIZED


#! FOLDER STRUCTURE/ FILE NAMES:
#* app contains our models and controllers (have our route actions)
#* config will have our configurations
#* config/routes has our routes
#* db is where our database, seeds, and migrations are

#! BUILDING A RAILS APP:
#* If you want to create an individual model, or controller, or a migration, do the following
#// rails g migration name_of_migration name:string age:integer
#* OTHERWISE, you can create all of those with one command.
#* Note that you can run 'rails d migration name_of_migration' to undo the file creation
#* ALSO NOTE that if the column's data type is a string, rails does it by default so you can just write 'name' and it'll be a string

#* 1. Use the generate resource command to build a table. User will be our example table-
#// rails g resource user name age:integer --no-test-framework
#* This will create a table of userS (plural) for us with the columns "name (string)", "age(integer)", and "timestamps(time)"

#* WHAT IS A MIGRATION? Migrations can be used as version control of our databases- we can see what changes are made with each migration.
#* When we want to modify our database, we make changes by creating migrations. If you want to create (or delete) a column in the db, create a migration:
#// rails g migration add_column_weight_to_user weight:integer
#* This adds the column "weight" to our user with the data type "integer"

#* 2. Once you're happy with how your table looks, you can create the database:
#// rails db:migrate
#* This compiles all your migrations and creates the final product, our database.

#* 3. We create seeds in our db/seeds.rb file, which would allow us to populate our databases upon creation.
#// User.create(name: "John Johnson", age: 37, weight: 190)
#* Once we have our seed file ready, we can run the command "rails db:seed" to populate our database with the pre-built data.
#* If there is no response, it is a good thing. If you prefer, you can type "puts 'done!'" in the seed file after the data so that you can see that it loaded successfully
#* You can also check your db directly, or you can just run the command "rails c" to open the console, then type 'User.all' and see all instances of the User object.

#* If you do rails db:seed twice, it will make duplicates. To avoid this, if you do rails db:seed:replant, it would reseed the database (starting at a higher id).

#* rails routes -> tells you all routes you have available at the moment
#* When we generate a resource, all of the possible CRUD routes are automatically generated by the "resource", which can be seen when you run "rails routes". 
#* If we want to make custom routes, here's the syntax:
#// get '/productions', to: 'productions/index'
#// post '/tables', to 'tables#create'
#* You can also choose which routes you want out of resources-
#// resources :tables, only: [:index, :create]
#* Alternatively, EXCLUDE allows you to exclude a route from resources-
#// resources :tables, exclude: [:show] --> all routes other than /show are accessible

#* 4. Define CRUD actions in the controllers
#// def index
#//     users = User.all
#//     render json: users, status: :ok
#// end 

#// def show
#//     render json: User.find(params[:id]), status: :ok    --> It searches the user table for an instance where the params id (search bar id) matches the user's id
#// end

#// def create
#//     user = User.create(user_params)
#//     render json: user, status: :created
#// end

#// def update
#//     user = User.find(params[:id])
#//     user.update(user_params)
#//     render json: production, status: :accepted
#// end

#// def destroy
#//     user = User.find(params[:id])
#//     user.destroy
#//     render json: {Message: "User deleted successfully!"}, status: :ok


#// private  --> (this keyword specifies that all methods beneath it are private)

#// def user_params
#//     params.permit(:name, :age, :weight)
#// end

#* Private methods are methods you can create within the class; cannot be accessed outside the class.

#* To start our server, we run "rails s"

#* 5. In the models, create associations as follows:
#// class employee < ApplicationRecord
#//     has_many :orders
#//     has_many :customers, through: :orders
#* We also put our validations in the models, as such:
#//     validates :order_number, presence: true, uniqueness: true
#* You can create custom validations (USE THE VALIDATE KEYWORD INSTEAD OF VALIDATES):
#//     validate :genre, :no_more_musicals

#// def no_more_musicals
#//     if self.genre == "Musical" && Production.where(ongoing: true, genre: 'Musical').length > 0
#//         errors.add(:genre, "Sorry only 1 musical at a time")
#//     end
#// end


#* 6. When we create a serializer, they replace whatever "render json:" we have, it returns custom data.
#// rails g serializer employee (make sure the serializer matches model you're serializing; SINGULAR)

#// class EmployeeSerializer < ActiveModel::Serializer
#//     attributes :id, :name, :age
#//     has_many :orders  --> (Because we have that association in the model, we can show the orders with the employee data)
#// end 

# To compare Ruby and Java, look at how you create an instance of an object:
# JAVA:
# Object o1 = new Object(params) <- invokes a constructor and passes arguments
# RUBY:
# o1 = Object.new(params)
# o1.save 

# OR you can do o1 = Object.create(params) to skip the .new and separate .save step. The former is a safer technique though


# In Java, there's the static keyword. If you apply it to a method, it would make that method apply to the class rather than the instance of the class
# In other words, that method becomes a "Class method". In Ruby, you have @ vs @@ to indicate an instance variable or method, vs a class variable or method.